package com.fclark.jqlib.main;

import static com.fclark.jqlib.Parameter.$PAR;
import static com.fclark.jqlib.Query.select;

import java.io.FileWriter;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.util.Date;

import com.fclark.jqlib.Entity;
import com.fclark.jqlib.Environment;
import com.fclark.jqlib.Resultable;
import com.fclark.jqlib.column.Column;

/**
 * 
 * @author Frederick Clark
 * @version 0.1 Feb 8th, 2011
 * @version 0.2 Mar 1, 2011.    Las entidades generadas incluyen un constructor default, 
 *                              un constructor que recibe un String alias y un método estático alias(String alias),
 *                              para cambiar el alias.
 * @version 0.3 Mar 22, 2011.   Se ajustó para que los campos sean generados con el identificador "final" y con el tipo de 
 *                              de dato correspondiente.
 *                              Se ajustó para que busque y especifique el Primary Key a cada tabla generada.
 * 
 * Mar 2, 2011. Frederick Clark <br>
 * TODO: Agregar la opción "javafy", para escoger si se quiere  que los campos se generen con nombres siguien el estándard de Sun
 * o con el nombre real del campo en la base de datos.<br>
 * TODO: Agregar una opción para escoger si se quiere generar solo las tablas, solo los sinónimos, solo las vistas o todas.<br>
 * Mar 16, 2011. <br>
 * TODO: Agregar la opción "typeAware" para escoger si se quiere que el tipo de la columna corresponda al tipo de datos 
 * real de la columna en la base de datos (Ej. VARCHAR2, CHAR, DATE, NUMBER, etc.)<br>
 * Mar 22, 2011.<br>
 * TODO: Agregar una opción para elegir si quiero crear cada entidad en una clase separada o crear una clase que represente
 * un esquema especificado, con todas las entidades como clases internas.<br>
 * 
 */
  
public class EntityImporter {
    /**
     * @param args
     */
    private static final String GENERATED_MESSAGE = "/**\n *  This class was generated by the JQLib EntityImporter on %1$s\n *\n */\n";
    private static final String IMPORTS = "import com.fclark.jqlib.Entity;\nimport com.fclark.jqlib.column.*;\n";
    
    public static void main(String[] args) throws Exception {
        
        Class.forName("oracle.jdbc.driver.OracleDriver");
        String url = "jdbc:oracle:thin:@connstr"; //args[0] -- connString
        String user = "user"; //args[1] -- user
        String pwd = "pwd"; //args[2] --password
        String schema = "schema"; //args[3]; -- schema
        String table = "tablename";  //args[5]; -- tableName, use "*" for all tables
        String pkg = "package"; //args[6]; -- package where generated classes will belong 
        String outPath = System.getProperty("user.dir").concat("\\src\\"); //args[7] path where the generated java files will be located    
        
        Environment.setConnection(DriverManager.getConnection(url, user,pwd));
        
        importModel(schema,table,pkg, outPath);
        
    }
    
    private static String javafy(String columnName) {
        String[] arrVal = columnName.toLowerCase().split("_");
        StringBuilder sb = new StringBuilder(arrVal[0]);
        for(int i=1; i < arrVal.length; i++)            
            sb.append(arrVal[i].substring(0,1).toUpperCase() + arrVal[i].substring(1));
                        
        return sb.toString();
    }
    public static void importModel(String schema, String table, String pkg, String outPath) throws Exception {
        StringBuilder classData, synData; 
        Resultable tablesQry, columnsQry, pkQuery, synQry;
        ResultSet tables, columns, synonyms; 
        FileWriter writer;
        double millis;
        int cantClases = 0;
        
        //Selecciona todas las tablas que cumplan con el criterio
        ALL_TABLES at = new ALL_TABLES();
        if(table.equals("*")) {
            tablesQry = select(at.TABLE_NAME).
                        from(at).
                        where(at.OWNER.equal($PAR)).
                        orderBy(1);
        }
        else
        {
            tablesQry = select(at.TABLE_NAME).
                        from(at).
                        where(at.OWNER.equal($PAR)).
                        and(at.TABLE_NAME.like($PAR)).
                        orderBy(1);
        }
        //Busca las columnas de la tabla actual
        ALL_TAB_COLUMNS atc = new ALL_TAB_COLUMNS(); 
        columnsQry = select(atc.COLUMN_NAME, 
                    atc.DATA_TYPE.replace("VARCHAR2","VARCHAR").as("DATA_TYPE"))
                    .from(atc)
                    .where(atc.OWNER.equal($PAR))
                    .and(atc.TABLE_NAME.equal($PAR))
                    .orderBy(atc.COLUMN_ID);
        
        //Busca el primary key de la tabla actual
        ALL_CONSTRAINTS cons = new ALL_CONSTRAINTS().setAlias("cons"); 
        ALL_CONS_COLUMNS col = new ALL_CONS_COLUMNS().setAlias("col");
        
        pkQuery = select(col.POSITION)
                 .from(col)
                 .where(col.OWNER.equal($PAR))
                 .and(col.TABLE_NAME.equal($PAR))
                 .and(col.COLUMN_NAME.equal($PAR))
                 .and(select(1)
                         .from(cons)
                         .where(cons.OWNER.equal(col.OWNER))
                         .and(cons.TABLE_NAME.equal(col.TABLE_NAME))
                         .and(cons.CONSTRAINT_NAME.equal(col.CONSTRAINT_NAME))
                         .and(cons.CONSTRAINT_TYPE.equal('P')).exists()
                 );
        
        //Busca los sinónimos de la tabla actual
        ALL_SYNONYMS syn = new ALL_SYNONYMS(); 
        synQry = select(syn.SYNONYM_NAME).
                from(syn).
                where(syn.OWNER.equal($PAR)).
                and(syn.TABLE_NAME.equal($PAR));
        
        //Search for table(s)    
        tables = table.equals("*") ? tablesQry.asResultSet(schema) : tablesQry.asResultSet(schema, table);
        //For all tables found

        while(tables.next()) {
            cantClases++;
            String tableName = tables.getString(at.TABLE_NAME.getName());
            System.out.print("generando clase "+ tableName+ " ...");
            millis = System.currentTimeMillis();
            classData  = new StringBuilder("package ").append(pkg).append(";\n\n");
            classData.append(String.format(GENERATED_MESSAGE, new Date().toString()));
            classData.append(IMPORTS);
            classData.append("\npublic class ").append(tableName).append(" extends Entity<").append(tableName);
            classData.append("> {\n\n");
            //Columns
            //Search for table columns
            columns = columnsQry.asResultSet(schema,tableName);
            //For all columns found
            String colType;
            String colName;
            while(columns.next()) {
                colName = columns.getString(atc.COLUMN_NAME.getName());
                colType = columns.getString(atc.DATA_TYPE.getName());;
                if(!(colType.equals("DATE") || colType.equals("NUMBER") || colType.equals("VARCHAR")))
                        colType = "Column";
                //System.out.println(pkQuery.toString());
                classData.append("\tpublic final ").append(colType).append(" ").append(colName).append(" = new ");
                classData.append(colType).append("(\"").append(colName);
                int pkIndex = pkQuery.getSingleValue(schema, table,colName);    //Busca el Primary Key, si existe.
                if(pkIndex > 0)
                    classData.append("\",this,").append(pkIndex).append(");\n");
                else
                    classData.append("\",this);\n");
            }//columns
            //Constructors
            classData.append('\n');
            classData.append("\tpublic ").append(tableName).append("() {\n");
            classData.append("\t\tsuper();\n\t}\n");            
            classData.append("\tpublic ").append(tableName).append("(String alias) {\n");
            classData.append("\t\tsuper(alias);\n\t}\n");
            //classData = new StringBuilder(classData.subSequence(0, classData.length() - 2)).append(";\n\n");
            columns.close();
            //Methods
            classData.append("\tpublic static ").append(tableName).append(" alias(String alias) {\n");
            classData.append("\t\treturn new ").append(tableName).append("(alias);\n\t}\n");
            classData.append("}\n");
            //Crea el archivo de la clase
            writer = new FileWriter(outPath + pkg.replace(".", "\\")+"\\"+ tableName.concat(".java"));
            writer.write(classData.toString());
            writer.flush();
            writer.close();
            System.out.println(((System.currentTimeMillis() - millis)/1000) + " sec");
            System.out.println("\tSearching for synonyms...");
            //Search for table synonyms
            synonyms = synQry.asResultSet(schema, tableName);
            boolean synFound = false;
            while(synonyms.next()) {
                millis = System.currentTimeMillis();
                synFound = true;
                String synName = synonyms.getString(syn.SYNONYM_NAME.getName());
                synData =  new StringBuilder("package "+pkg+";\n\n");
                synData.append("public class ").append(synName);
                synData.append(" extends ").append(tableName).append(" {\n") ;
                //Constructor
                synData.append("\tpublic ").append(synName).append("() {\n");
                synData.append("\t\tsuper();\n\t}\n");                            
                synData.append("\tpublic ").append(synName).append("(String alias) {\n");
                synData.append("\t\tsuper(alias);\n\t}\n");
                //
                synData.append("\tpublic static ").append(synName).append(" alias(String alias) {\n");
                synData.append("\t\treturn new ").append(synName).append("(alias);\n\t}\n");
                synData.append("}\n");
                
                writer = new FileWriter(outPath + pkg.replace(".", "\\")+"\\"+ synName.concat(".java"));
                writer.write(synData.toString());
                writer.close();
                System.out.print("\t generando clase del sinónimo " + synName+ " ...");
                System.out.println(((System.currentTimeMillis() - millis)/1000) + " sec");
            }
            synonyms.close();
            if(!synFound)
                System.out.println("\tNo synonyms for table " + tableName + " were found.");
        }//tables
        System.out.println("\nProceso de generación terminado. Se generaron "+ cantClases + " clases.");
        tables.close();
        columnsQry.close();
        tablesQry.close();
    }
    
    static class ALL_TABLES extends Entity<ALL_TABLES> {
        public final Column 
            OWNER = new Column("OWNER",this),
            TABLE_NAME = new Column("TABLE_NAME",this);
    }
    
    static class ALL_TAB_COLUMNS extends Entity<ALL_TAB_COLUMNS> {
        public final Column OWNER = new Column("OWNER",this),
                            TABLE_NAME = new Column("TABLE_NAME",this),
                            COLUMN_NAME = new Column("COLUMN_NAME",this),
                            DATA_TYPE = new Column("DATA_TYPE",this),
                            COLUMN_ID = new Column("COLUMN_ID",this);
    }
            
    static class ALL_CONS_COLUMNS extends Entity<ALL_CONS_COLUMNS> {
        public final Column OWNER = new Column("OWNER",this),
                        TABLE_NAME = new Column("TABLE_NAME",this),
                        CONSTRAINT_NAME = new Column("CONSTRAINT_NAME",this),
                        COLUMN_NAME = new Column("COLUMN_NAME",this),
                        POSITION = new Column("POSITION",this);
    }
    
    static class ALL_CONSTRAINTS extends Entity<ALL_CONSTRAINTS> {
        public final Column OWNER = new Column("OWNER",this),
                            TABLE_NAME = new Column("TABLE_NAME",this),
                            CONSTRAINT_NAME =  new Column("CONSTRAINT_NAME",this),
                            CONSTRAINT_TYPE =  new Column("CONSTRAINT_TYPE",this);
    }
    
    static class ALL_SYNONYMS extends Entity<ALL_SYNONYMS> {
        public final Column OWNER = new Column("OWNER",this),
                        TABLE_NAME = new Column("TABLE_NAME",this),
                        SYNONYM_NAME = new Column("SYNONYM_NAME",this);             
    }
    

}
